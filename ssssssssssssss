[33mcommit e01b0e418284a4e413713f7882b2af0c4b9408c9[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mmaster[m[33m)[m
Author: Yharlm <lambrins22@gmail.com>
Date:   Thu Jun 12 14:00:17 2025 +0300

    Cubiing

[1mdiff --git a/Rotating shape/Program.cs b/Rotating shape/Program.cs[m
[1mindex 669fa80..8616ab3 100644[m
[1m--- a/Rotating shape/Program.cs[m	
[1m+++ b/Rotating shape/Program.cs[m	
[36m@@ -27,7 +27,7 @@[m [mnamespace Rotating_shape[m
         {[m
             public List<point> points = new List<point>();[m
             public List<Connection> Edges = new List<Connection>();[m
[31m-[m
[32m+[m[32m            public float Fov =1.3f; // Field of view, used to scale the Z coordinate for perspective effect[m
             public void addPoint(float x, float y, float z)[m
             {[m
                 points.Add(new point(x, y, z));[m
[36m@@ -62,13 +62,32 @@[m [mnamespace Rotating_shape[m
             }[m
             public void drawLine(Connection C, Vector2 Offset)[m
             {[m
[31m-                var a = C.A;[m
[32m+[m[32m                var a = C.A.position;[m
[32m+[m[32m                var b = C.B.position;[m
[32m+[m[32m                float Za = 1;[m
[32m+[m[32m                float Zb = 1;[m
                 [m
[31m-[m
[31m-                var b = C.B;[m
                 [m
[32m+[m[32m                if(a.Z < 0 )[m
[32m+[m[32m                {[m
[32m+[m[32m                    Za = Fov;[m
[32m+[m[32m                }[m
[32m+[m[32m                if(b.Z < 0)[m
[32m+[m[32m                {[m
[32m+[m[41m                   [m
[32m+[m[32m                    Zb = Fov;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (a.Z < 0)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Za = Fov;[m
[32m+[m[32m                }[m
[32m+[m[32m                if (b.Z < 0)[m
[32m+[m[32m                {[m
[32m+[m
[32m+[m[32m                    Zb = Fov;[m
[32m+[m[32m                }[m
 [m
[31m-                DrawLine((int)(a.position.X + Offset.X) * a.position.Z, (int)(a.position.Y + Offset.Y) * a.position.Z, (int)(b.position.X + Offset.X), (int)(b.position.Y + Offset.Y));[m
[32m+[m[32m                DrawLine((int)(a.X * Za + Offset.X), (int)(a.Y * Za + Offset.Y), (int)(b.X * Zb + Offset.X ), (int)(b.Y * Zb + Offset.Y));[m
 [m
             }[m
 [m
[36m@@ -124,8 +143,8 @@[m [mnamespace Rotating_shape[m
 [m
                 foreach (Connection C in cube.Edges)[m
                 {[m
[31m-                    if(C.A.position.Z > -lenght && C.B.position.Z > -lenght/0.905)[m
[31m-                    cube.drawLine(C, Offset);[m
[32m+[m[32m                    //if (C.A.position.Z > -lenght && C.B.position.Z > -lenght / 0.905)[m
[32m+[m[32m                        cube.drawLine(C, Offset);[m
                 }[m
                 //cube.drawLine(0, 1, Offset);[m
                 //cube.drawLine(1, 2, Offset);[m
[36m@@ -141,7 +160,7 @@[m [mnamespace Rotating_shape[m
                 //cube.drawLine(3, 7, Offset);[m
                 var ListToDisplay = cube.Edges;[m
                 //var ListToDisplay = cube.Edges.FindAll(x => float.Max(x.A.position.Z, x.B.position.Z) > 0);[m
[31m-                [m
[32m+[m
 [m
                 // This line is not necessary, but it can be used to force the evaluation of the points if needed.[m
 [m

[33mcommit acdc434a7be7f6195ae00b45a4f419dc59176096[m
Author: Students <Students@DESKTOP-DAPA1OB>
Date:   Wed Jun 11 23:20:27 2025 -1100

    Cubed

[1mdiff --git a/Rotating shape/Program.cs b/Rotating shape/Program.cs[m
[1mindex 0c7cfc7..669fa80 100644[m
[1m--- a/Rotating shape/Program.cs[m	
[1m+++ b/Rotating shape/Program.cs[m	
[36m@@ -60,6 +60,17 @@[m [mnamespace Rotating_shape[m
                 DrawLine((int)(points[a].position.X + Offset.X), (int)(points[a].position.Y + Offset.Y), (int)(points[b].position.X + Offset.X), (int)(points[b].position.Y + Offset.Y));[m
 [m
             }[m
[32m+[m[32m            public void drawLine(Connection C, Vector2 Offset)[m
[32m+[m[32m            {[m
[32m+[m[32m                var a = C.A;[m
[32m+[m[41m                [m
[32m+[m
[32m+[m[32m                var b = C.B;[m
[32m+[m[41m                [m
[32m+[m
[32m+[m[32m                DrawLine((int)(a.position.X + Offset.X) * a.position.Z, (int)(a.position.Y + Offset.Y) * a.position.Z, (int)(b.position.X + Offset.X), (int)(b.position.Y + Offset.Y));[m
[32m+[m
[32m+[m[32m            }[m
 [m
 [m
         }[m
[36m@@ -100,17 +111,22 @@[m [mnamespace Rotating_shape[m
             Vector2 Offset = new Vector2(lenght * 2, lenght * 2);[m
             while (true)[m
             {[m
[31m-                foreach (Connection C in cube.Edges.FindAll(x => float.Max(x.A.position.Z, x.B.position.Z) > lenght))[m
[31m-                {[m
[31m-                    int index = cube.Edges.IndexOf(C);[m
[31m-                    if (index > 0 && index < cube.Edges.Count)[m
[31m-                    {[m
[31m-                        cube.drawLine(index - 1, index, Offset);[m
[31m-                    }[m
[31m-[m
[31m-                }[m
[32m+[m[32m                //foreach (Connection C in cube.Edges.FindAll(x => float.Max(x.A.position.Z, x.B.position.Z) > 0))[m
[32m+[m[32m                //{[m
[32m+[m[32m                //    int index = cube.Edges.IndexOf(C);[m
[32m+[m[32m                //    if (index > 0 && index < cube.Edges.FindAll(x => float.Max(x.A.position.Z, x.B.position.Z) > 0).Count())[m
[32m+[m[32m                //    {[m
[32m+[m[32m                //        cube.drawLine(index - 1, index, Offset);[m
[32m+[m[32m                //    }[m
[32m+[m
[32m+[m[32m                //}[m
                 cube.Rotate(Orientation.Y, Orientation.X, Orientation.Z);[m
 [m
[32m+[m[32m                foreach (Connection C in cube.Edges)[m
[32m+[m[32m                {[m
[32m+[m[32m                    if(C.A.position.Z > -lenght && C.B.position.Z > -lenght/0.905)[m
[32m+[m[32m                    cube.drawLine(C, Offset);[m
[32m+[m[32m                }[m
                 //cube.drawLine(0, 1, Offset);[m
                 //cube.drawLine(1, 2, Offset);[m
                 //cube.drawLine(2, 3, Offset);[m
[36m@@ -123,15 +139,8 @@[m [mnamespace Rotating_shape[m
                 //cube.drawLine(1, 5, Offset);[m
                 //cube.drawLine(2, 6, Offset);[m
                 //cube.drawLine(3, 7, Offset);[m
[31m-                foreach (point p in cube.points.FindAll(x => x.position.Z > -lenght))[m
[31m-                {[m
[31m-                    int index = cube.points.IndexOf(p);[m
[31m-[m
[31m-[m
[31m-                    float z = p.position.Z / 2;[m
[31m-                    WriteAt(p.position.X + Offset.X, p.position.Y + Offset.Y);[m
[31m-[m
[31m-                }[m
[32m+[m[32m                var ListToDisplay = cube.Edges;[m
[32m+[m[32m                //var ListToDisplay = cube.Edges.FindAll(x => float.Max(x.A.position.Z, x.B.position.Z) > 0);[m
                 [m
 [m
                 // This line is not necessary, but it can be used to force the evaluation of the points if needed.[m

[33mcommit c7e1a9b3983072a2fae07e525031ae1d0f78834d[m
Author: Students <Students@DESKTOP-B4IKMP3>
Date:   Wed Jun 11 13:18:38 2025 +0300

    E

[1mdiff --git a/Rotating shape/Program.cs b/Rotating shape/Program.cs[m
[1mindex 8e1f301..0c7cfc7 100644[m
[1m--- a/Rotating shape/Program.cs[m	
[1m+++ b/Rotating shape/Program.cs[m	
[36m@@ -13,17 +13,30 @@[m [mnamespace Rotating_shape[m
             }[m
 [m
         }[m
[31m-[m
[32m+[m[32m        class Connection : shape[m
[32m+[m[32m        {[m
[32m+[m[32m            public Connection(point a, point b)[m
[32m+[m[32m            {[m
[32m+[m[32m                A = a;[m
[32m+[m[32m                B = b;[m
[32m+[m[32m            }[m
[32m+[m[32m            public point A;[m
[32m+[m[32m            public point B;[m
[32m+[m[32m        }[m
         class shape[m
         {[m
             public List<point> points = new List<point>();[m
[32m+[m[32m            public List<Connection> Edges = new List<Connection>();[m
 [m
             public void addPoint(float x, float y, float z)[m
             {[m
                 points.Add(new point(x, y, z));[m
             }[m
 [m
[31m-[m
[32m+[m[32m            public void addEdge(int a, int b)[m
[32m+[m[32m            {[m
[32m+[m[32m                Edges.Add(new Connection(points[a], points[b]));[m
[32m+[m[32m            }[m
 [m
             public void Rotate(float angleX, float angleY, float angleZ)[m
             {[m
[36m@@ -40,7 +53,7 @@[m [mnamespace Rotating_shape[m
                 }[m
             }[m
 [m
[31m-            public void drawLine(int B,int A,Vector2 Offset)[m
[32m+[m[32m            public void drawLine(int B, int A, Vector2 Offset)[m
             {[m
                 int a = A;[m
                 int b = B;[m
[36m@@ -51,11 +64,15 @@[m [mnamespace Rotating_shape[m
 [m
         }[m
 [m
[31m-[m
[32m+[m[32m        /*[m
[32m+[m[41m         [m
[32m+[m[41m          [m
[32m+[m[41m         [m
[32m+[m[32m        */[m
 [m
         static void Main(string[] args)[m
         {[m
[31m-            int lenght  = 20;[m
[32m+[m[32m            int lenght = 20;[m
             shape cube = new shape();[m
             cube.addPoint(-lenght, -lenght, -lenght);[m
             cube.addPoint(lenght, -lenght, -lenght);[m
[36m@@ -66,34 +83,92 @@[m [mnamespace Rotating_shape[m
             cube.addPoint(lenght, lenght, lenght);[m
             cube.addPoint(-lenght, lenght, lenght);[m
 [m
[31m-            Vector2 Offset = new Vector2(lenght*2, lenght*2);[m
[32m+[m[32m            cube.addEdge(0, 1);[m
[32m+[m[32m            cube.addEdge(1, 2);[m
[32m+[m[32m            cube.addEdge(2, 3);[m
[32m+[m[32m            cube.addEdge(3, 0);[m
[32m+[m[32m            cube.addEdge(4, 5);[m
[32m+[m[32m            cube.addEdge(5, 6);[m
[32m+[m[32m            cube.addEdge(6, 7);[m
[32m+[m[32m            cube.addEdge(7, 4);[m
[32m+[m[32m            cube.addEdge(0, 4);[m
[32m+[m[32m            cube.addEdge(1, 5);[m
[32m+[m[32m            cube.addEdge(2, 6);[m
[32m+[m[32m            cube.addEdge(3, 7);[m
[32m+[m
[32m+[m[32m            Vector3 Orientation = new Vector3(0, 0, 0);[m
[32m+[m[32m            Vector2 Offset = new Vector2(lenght * 2, lenght * 2);[m
             while (true)[m
             {[m
[31m-                [m
[31m-                cube.Rotate(0.01f, 0.1f, 0.1f);[m
[31m-                foreach (point p in cube.points)[m
[32m+[m[32m                foreach (Connection C in cube.Edges.FindAll(x => float.Max(x.A.position.Z, x.B.position.Z) > lenght))[m
                 {[m
[32m+[m[32m                    int index = cube.Edges.IndexOf(C);[m
[32m+[m[32m                    if (index > 0 && index < cube.Edges.Count)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        cube.drawLine(index - 1, index, Offset);[m
[32m+[m[32m                    }[m
[32m+[m
[32m+[m[32m                }[m
[32m+[m[32m                cube.Rotate(Orientation.Y, Orientation.X, Orientation.Z);[m
[32m+[m
[32m+[m[32m                //cube.drawLine(0, 1, Offset);[m
[32m+[m[32m                //cube.drawLine(1, 2, Offset);[m
[32m+[m[32m                //cube.drawLine(2, 3, Offset);[m
[32m+[m[32m                //cube.drawLine(3, 0, Offset);[m
[32m+[m[32m                //cube.drawLine(4, 5, Offset);[m
[32m+[m[32m                //cube.drawLine(5, 6, Offset);[m
[32m+[m[32m                //cube.drawLine(6, 7, Offset);[m
[32m+[m[32m                //cube.drawLine(7, 4, Offset);[m
[32m+[m[32m                //cube.drawLine(0, 4, Offset);[m
[32m+[m[32m                //cube.drawLine(1, 5, Offset);[m
[32m+[m[32m                //cube.drawLine(2, 6, Offset);[m
[32m+[m[32m                //cube.drawLine(3, 7, Offset);[m
[32m+[m[32m                foreach (point p in cube.points.FindAll(x => x.position.Z > -lenght))[m
[32m+[m[32m                {[m
[32m+[m[32m                    int index = cube.points.IndexOf(p);[m
[32m+[m
[32m+[m
                     float z = p.position.Z / 2;[m
                     WriteAt(p.position.X + Offset.X, p.position.Y + Offset.Y);[m
 [m
[31m-[m
[31m-                                                                                                                                   [m
                 }[m
                 [m
[31m-                cube.drawLine(0, 1, Offset);[m
[31m-                cube.drawLine(1, 2, Offset);[m
[31m-                cube.drawLine(2, 3, Offset);[m
[31m-                cube.drawLine(3, 0, Offset);[m
[31m-                cube.drawLine(4, 5, Offset);[m
[31m-                cube.drawLine(5, 6, Offset);[m
[31m-                cube.drawLine(6, 7, Offset);[m
[31m-                cube.drawLine(7, 4, Offset);[m
[31m-                cube.drawLine(0, 4, Offset);[m
[31m-                cube.drawLine(1, 5, Offset);[m
[31m-                cube.drawLine(2, 6, Offset);[m
[31m-                cube.drawLine(3, 7, Offset);[m
 [m
[32m+[m[32m                // This line is not necessary, but it can be used to force the evaluation of the points if needed.[m
 [m
[32m+[m[32m                if (Console.KeyAvailable)[m
[32m+[m[32m                {[m
[32m+[m[32m                    float speed = 0.001f;[m
[32m+[m[32m                    ConsoleKeyInfo key = Console.ReadKey(true);[m
[32m+[m[32m                    if (key.Key == ConsoleKey.D)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Orientation.X += speed;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (key.Key == ConsoleKey.A)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Orientation.X -= speed;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (key.Key == ConsoleKey.W)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Orientation.Y -= speed;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (key.Key == ConsoleKey.S)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Orientation.Y += speed;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (key.Key == ConsoleKey.Q)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Orientation.Z += speed;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (key.Key == ConsoleKey.E)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Orientation.Z -= speed;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if (key.Key == ConsoleKey.Escape)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        Orientation = new Vector3(0, 0, 0);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
 [m
 [m
 [m
[36m@@ -140,7 +215,7 @@[m [mnamespace Rotating_shape[m
             }[m
         }[m
 [m
[31m-        [m
[32m+[m
 [m
     }[m
 }[m

[33mcommit 42f5d7efbb8f7c8c366bd545eb2b69052c2147b0[m
Author: Students <Students@DESKTOP-DAPA1OB>
Date:   Tue Jun 10 21:40:23 2025 -1100

    WOrks Wow also study matirces

[1mdiff --git a/Rotating shape/Program.cs b/Rotating shape/Program.cs[m
[1mindex 93cd62f..8e1f301 100644[m
[1m--- a/Rotating shape/Program.cs[m	
[1m+++ b/Rotating shape/Program.cs[m	
[36m@@ -1,191 +1,127 @@[m
[31m-ï»¿using System.ComponentModel;[m
[31m-using System.Runtime.CompilerServices;[m
[32m+[m[32mï»¿using System.Numerics;[m
 [m
 namespace Rotating_shape[m
 {[m
     internal class Program[m
     {[m
[31m-[m
         class point[m
         {[m
[31m-            public double x = 0;[m
[31m-            public double y = 0;[m
[31m-[m
[31m-            public point(double x, double y)[m
[31m-            {[m
[31m-                this.x = x;[m
[31m-                this.y = y;[m
[31m-            }[m
[31m-            public point(double x, double y,int size)[m
[32m+[m[32m            public Vector3 position;[m
[32m+[m[32m            public point(float x, float y, float z)[m
             {[m
[31m-                this.x = x*size;[m
[31m-                this.y = y*size;[m
[32m+[m[32m                position = new Vector3(x, y, z);[m
             }[m
[32m+[m
         }[m
 [m
         class shape[m
         {[m
[31m-            public point a, b, c, d;[m
[31m-            public int x, y;[m
[31m-            public int length = 1;[m
[32m+[m[32m            public List<point> points = new List<point>();[m
 [m
[31m-            public shape(int size)[m
[32m+[m[32m            public void addPoint(float x, float y, float z)[m
             {[m
[31m-                [m
[31m-                int s = size;[m
[31m-                [m
[31m-                a = new point(-1, -1, s);[m
[31m-                b = new point(0.5, -0.5, s);[m
[31m-                c = new point(1, 1, s);[m
[31m-                d = new point(-0.5, 0.5, s);[m
[32m+[m[32m                points.Add(new point(x, y, z));[m
             }[m
[31m-        }[m
[31m-        class Polygon[m
[31m-        {[m
[31m-            public List<point> Points= new List<point>();[m
[31m-            public int x, y;[m
[31m-            public int length = 1;[m
 [m
[31m-            public Polygon(int size)[m
[32m+[m
[32m+[m
[32m+[m[32m            public void Rotate(float angleX, float angleY, float angleZ)[m
             {[m
[32m+[m[32m                Matrix4x4 rotationX = Matrix4x4.CreateRotationX(angleX);[m
[32m+[m[32m                Matrix4x4 rotationY = Matrix4x4.CreateRotationY(angleY);[m
[32m+[m[32m                Matrix4x4 rotationZ = Matrix4x4.CreateRotationZ(angleZ);[m
[32m+[m
[32m+[m[32m                foreach (point p in points)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Vector3 rotatedPosition = Vector3.Transform(p.position, rotationX);[m
[32m+[m[32m                    rotatedPosition = Vector3.Transform(rotatedPosition, rotationY);[m
[32m+[m[32m                    rotatedPosition = Vector3.Transform(rotatedPosition, rotationZ);[m
[32m+[m[32m                    p.position = rotatedPosition;[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
 [m
[31m-                int s = size;[m
[32m+[m[32m            public void drawLine(int B,int A,Vector2 Offset)[m
[32m+[m[32m            {[m
[32m+[m[32m                int a = A;[m
[32m+[m[32m                int b = B;[m
[32m+[m[32m                DrawLine((int)(points[a].position.X + Offset.X), (int)(points[a].position.Y + Offset.Y), (int)(points[b].position.X + Offset.X), (int)(points[b].position.Y + Offset.Y));[m
 [m
[31m-                Points.Add( new point(-1, -1, s));[m
[31m-                Points.Add(new point(1, -1, s));[m
[31m-                Points.Add(new point(1, 1, s));[m
[31m-                Points.Add(new point(-1, 2, s));[m
             }[m
[32m+[m
[32m+[m
         }[m
 [m
 [m
[31m-        static void Rotate(float angle, shape shape)[m
[31m-        {[m
[31m-            float radians = angle * (float)(Math.PI / 180.0);[m
[31m-            //Matrix for rotation[m
[31m-            float cos = (float)Math.Cos(radians);[m
[31m-            float sin = (float)Math.Sin(radians);[m
[31m-            // Rotate each point[m
[31m-            point tempA = new point(shape.a.x, shape.a.y);[m
[31m-            point tempB = new point(shape.b.x, shape.b.y);[m
[31m-            point tempC = new point(shape.c.x, shape.c.y);[m
[31m-            point tempD = new point(shape.d.x, shape.d.y);[m
[31m-[m
[31m-            tempA.x = shape.a.x * cos - shape.a.y * sin;[m
[31m-            tempA.y = shape.a.x * sin + shape.a.y * cos;[m
[31m-            tempB.x = shape.b.x * cos - shape.b.y * sin;[m
[31m-            tempB.y = shape.b.x * sin + shape.b.y * cos;[m
[31m-            tempC.x = shape.c.x * cos - shape.c.y * sin;[m
[31m-            tempC.y = shape.c.x * sin + shape.c.y * cos;[m
[31m-            tempD.x = shape.d.x * cos - shape.d.y * sin;[m
[31m-            tempD.y = shape.d.x * sin + shape.d.y * cos;[m
[31m-[m
[31m-            // Update the shape points[m
[31m-            shape.a = tempA;[m
[31m-            shape.b = tempB;[m
[31m-            shape.c = tempC;[m
[31m-                shape.d = tempD;[m
[31m-[m
[31m-            [m
 [m
[31m-        }[m
         static void Main(string[] args)[m
         {[m
[31m-            float time = 0;[m
[31m-            Thread deltatime = new Thread(() =>[m
[31m-            {[m
[31m-                while (true)[m
[31m-                {[m
[31m-                    Thread.Sleep(1);[m
[31m-                    time += 0.001f; // Increment time by 1 millisecond[m
[31m-                }[m
[31m-            });[m
[31m-            Console.ForegroundColor = ConsoleColor.Blue;[m
[31m-[m
[31m-            shape square = new shape(21);[m
[31m-            shape square2 = new shape(17);[m
[31m-            square.x = 70;[m
[31m-            square.y = 60;[m
[31m-            square2.x = 70;[m
[31m-            square2.y = 60;[m
[31m-            shape square3 = new shape(10);[m
[31m-            shape square4 = new shape(13);[m
[31m-            square3.x = 70;[m
[31m-            square3.y = 60;[m
[31m-            square4.x = 70;[m
[31m-            square4.y = 60;[m
[31m-            Console.ReadLine();[m
[31m-            float speed = 0f;[m
[31m-            var input = Console.ReadKey().Key;[m
[32m+[m[32m            int lenght  = 20;[m
[32m+[m[32m            shape cube = new shape();[m
[32m+[m[32m            cube.addPoint(-lenght, -lenght, -lenght);[m
[32m+[m[32m            cube.addPoint(lenght, -lenght, -lenght);[m
[32m+[m[32m            cube.addPoint(lenght, lenght, -lenght);[m
[32m+[m[32m            cube.addPoint(-lenght, lenght, -lenght);[m
[32m+[m[32m            cube.addPoint(-lenght, -lenght, lenght);[m
[32m+[m[32m            cube.addPoint(lenght, -lenght, lenght);[m
[32m+[m[32m            cube.addPoint(lenght, lenght, lenght);[m
[32m+[m[32m            cube.addPoint(-lenght, lenght, lenght);[m
[32m+[m
[32m+[m[32m            Vector2 Offset = new Vector2(lenght*2, lenght*2);[m
             while (true)[m
             {[m
                 [m
[31m-                if (Console.KeyAvailable)[m
[32m+[m[32m                cube.Rotate(0.01f, 0.1f, 0.1f);[m
[32m+[m[32m                foreach (point p in cube.points)[m
                 {[m
[31m-                    input = Console.ReadKey(true).Key;[m
[31m-                }[m
[32m+[m[32m                    float z = p.position.Z / 2;[m
[32m+[m[32m                    WriteAt(p.position.X + Offset.X, p.position.Y + Offset.Y);[m
 [m
 [m
[31m-                Rotate(speed, square);[m
[31m-                if (input == ConsoleKey.E)[m
[31m-                {[m
[31m-                    speed += 0.1f;[m
[31m-                    [m
[31m-                }[m
[31m-                else if (input == ConsoleKey.Q)[m
[31m-                {[m
[31m-                    speed -= 0.1f;[m
[32m+[m[41m                                                                                                                                   [m
                 }[m
[31m-                else[m
[31m-                {[m
[31m-                    if (speed > 0)[m
[31m-                    {[m
[31m-                        speed -= 0.1f;[m
[31m-                    }[m
[31m-                    else if(speed < 0)[m
[31m-                    {[m
[31m-                        speed += 0.1f;[m
[31m-                    }[m
[31m-                }[m
[31m-                input = ConsoleKey.None;[m
[31m-                Thread.Sleep(10);[m
[31m-                Console.Clear();[m
[31m-                [m
[31m-               [m
[31m-                WriteAt("â–ˆâ–ˆ", square);[m
                 [m
[32m+[m[32m                cube.drawLine(0, 1, Offset);[m
[32m+[m[32m                cube.drawLine(1, 2, Offset);[m
[32m+[m[32m                cube.drawLine(2, 3, Offset);[m
[32m+[m[32m                cube.drawLine(3, 0, Offset);[m
[32m+[m[32m                cube.drawLine(4, 5, Offset);[m
[32m+[m[32m                cube.drawLine(5, 6, Offset);[m
[32m+[m[32m                cube.drawLine(6, 7, Offset);[m
[32m+[m[32m                cube.drawLine(7, 4, Offset);[m
[32m+[m[32m                cube.drawLine(0, 4, Offset);[m
[32m+[m[32m                cube.drawLine(1, 5, Offset);[m
[32m+[m[32m                cube.drawLine(2, 6, Offset);[m
[32m+[m[32m                cube.drawLine(3, 7, Offset);[m
[32m+[m
[32m+[m
[32m+[m
[32m+[m
 [m
 [m
 [m
[32m+[m
[32m+[m[32m                Thread.Sleep(10);[m
[32m+[m[32m                //Console.ReadLine();[m
[32m+[m[32m                Console.Clear();[m
             }[m
 [m
 [m
[32m+[m
         }[m
 [m
[31m-        static void WriteAt(string text, int x, int y)[m
[32m+[m[32m        static void WriteAt(float x, float y)[m
         {[m
[32m+[m[32m            try[m
[32m+[m[32m            {[m
[32m+[m[32m                Console.SetCursorPosition((int)x * 2, (int)y);[m
[32m+[m[32m                Console.Write("â–ˆâ–ˆ");[m
[32m+[m[32m            }[m
[32m+[m[32m            catch { }[m
 [m
[31m-            Console.SetCursorPosition(x, y);[m
[31m-            Console.Write(text);[m
         }[m
[31m-        static void WriteAt(string text, shape shape)[m
[31m-        {[m
[31m-            int lenght = shape.length;[m
[31m-            WriteAt(text, 2*((int)shape.a.x + shape.x), (int)shape.a.y+shape.y);[m
[31m-[m
[31m-            WriteAt(text, 2*((int)shape.b.x + shape.x), (int)shape.b.y+shape.y);[m
[31m-            [m
[31m-            WriteAt(text, 2*((int)shape.c.x + shape.x), (int)shape.c.y+shape.y);[m
[31m-            WriteAt(text, 2*((int)shape.d.x + shape.x), (int)shape.d.y+shape.y);[m
[31m-            drawLine(((int)shape.a.x + shape.x), (int)shape.a.y + shape.y,((int)shape.b.x + shape.x), (int)shape.b.y + shape.y);[m
[31m-            drawLine(((int)shape.b.x + shape.x), (int)shape.b.y + shape.y, ((int)shape.c.x + shape.x), (int)shape.c.y + shape.y);[m
[31m-            drawLine(((int)shape.c.x + shape.x), (int)shape.c.y + shape.y, ((int)shape.d.x + shape.x), (int)shape.d.y + shape.y);[m
[31m-            drawLine(((int)shape.d.x + shape.x), (int)shape.d.y + shape.y, ((int)shape.a.x + shape.x), (int)shape.a.y + shape.y);[m
[31m-[m
 [m
[31m-        }[m
 [m
[31m-        static void drawLine(int x1, int y1, int x2, int y2)[m
[32m+[m[32m        static void DrawLine(int x1, int y1, int x2, int y2)[m
         {[m
             int dx = x2 - x1;[m
             int dy = y2 - y1;[m
[36m@@ -198,10 +134,13 @@[m [mnamespace Rotating_shape[m
 [m
             for (int i = 0; i <= steps; i++)[m
             {[m
[31m-                WriteAt("â–ˆâ–ˆ", (int)x*2, (int)y);[m
[32m+[m[32m                WriteAt((int)x, (int)y);[m
                 x += xIncrement;[m
                 y += yIncrement;[m
             }[m
         }[m
[32m+[m
[32m+[m[41m        [m
[32m+[m
     }[m
 }[m

[33mcommit 4a7f78b995306390b8fd93a80853fb430b05b006[m
Author: Yharlm <lambrins22@gmail.com>
Date:   Wed Jun 4 10:35:20 2025 +0300

    E

[1mdiff --git a/Rotating shape/Program.cs b/Rotating shape/Program.cs[m
[1mindex 04c0d63..93cd62f 100644[m
[1m--- a/Rotating shape/Program.cs[m	
[1m+++ b/Rotating shape/Program.cs[m	
[36m@@ -35,11 +35,29 @@[m [mnamespace Rotating_shape[m
                 int s = size;[m
                 [m
                 a = new point(-1, -1, s);[m
[31m-                b = new point(1, -1, s);[m
[32m+[m[32m                b = new point(0.5, -0.5, s);[m
                 c = new point(1, 1, s);[m
[31m-                d = new point(-1, 1, s);[m
[32m+[m[32m                d = new point(-0.5, 0.5, s);[m
             }[m
         }[m
[32m+[m[32m        class Polygon[m
[32m+[m[32m        {[m
[32m+[m[32m            public List<point> Points= new List<point>();[m
[32m+[m[32m            public int x, y;[m
[32m+[m[32m            public int length = 1;[m
[32m+[m
[32m+[m[32m            public Polygon(int size)[m
[32m+[m[32m            {[m
[32m+[m
[32m+[m[32m                int s = size;[m
[32m+[m
[32m+[m[32m                Points.Add( new point(-1, -1, s));[m
[32m+[m[32m                Points.Add(new point(1, -1, s));[m
[32m+[m[32m                Points.Add(new point(1, 1, s));[m
[32m+[m[32m                Points.Add(new point(-1, 2, s));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
 [m
         static void Rotate(float angle, shape shape)[m
         {[m
[36m@@ -82,7 +100,7 @@[m [mnamespace Rotating_shape[m
                     time += 0.001f; // Increment time by 1 millisecond[m
                 }[m
             });[m
[31m-[m
[32m+[m[32m            Console.ForegroundColor = ConsoleColor.Blue;[m
 [m
             shape square = new shape(21);[m
             shape square2 = new shape(17);[m
[36m@@ -97,20 +115,45 @@[m [mnamespace Rotating_shape[m
             square4.x = 70;[m
             square4.y = 60;[m
             Console.ReadLine();[m
[31m-            while(true)[m
[32m+[m[32m            float speed = 0f;[m
[32m+[m[32m            var input = Console.ReadKey().Key;[m
[32m+[m[32m            while (true)[m
             {[m
[31m-[m
                 [m
[32m+[m[32m                if (Console.KeyAvailable)[m
[32m+[m[32m                {[m
[32m+[m[32m                    input = Console.ReadKey(true).Key;[m
[32m+[m[32m                }[m
[32m+[m
[32m+[m
[32m+[m[32m                Rotate(speed, square);[m
[32m+[m[32m                if (input == ConsoleKey.E)[m
[32m+[m[32m                {[m
[32m+[m[32m                    speed += 0.1f;[m
[32m+[m[41m                    [m
[32m+[m[32m                }[m
[32m+[m[32m                else if (input == ConsoleKey.Q)[m
[32m+[m[32m                {[m
[32m+[m[32m                    speed -= 0.1f;[m
[32m+[m[32m                }[m
[32m+[m[32m                else[m
[32m+[m[32m                {[m
[32m+[m[32m                    if (speed > 0)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        speed -= 0.1f;[m
[32m+[m[32m                    }[m
[32m+[m[32m                    else if(speed < 0)[m
[32m+[m[32m                    {[m
[32m+[m[32m                        speed += 0.1f;[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m                input = ConsoleKey.None;[m
                 Thread.Sleep(10);[m
                 Console.Clear();[m
[31m-                Rotate(5, square);[m
[31m-                Rotate(-2, square2);[m
[32m+[m[41m                [m
[32m+[m[41m               [m
                 WriteAt("â–ˆâ–ˆ", square);[m
[31m-                WriteAt("â–ˆâ–ˆ", square2);[m
[31m-                Rotate(3, square3);[m
[31m-                Rotate(1, square4);[m
[31m-                WriteAt("â–ˆâ–ˆ", square3);[m
[31m-                WriteAt("â–ˆâ–ˆ", square4);[m
[32m+[m[41m                [m
 [m
 [m
 [m
[36m@@ -139,6 +182,7 @@[m [mnamespace Rotating_shape[m
             drawLine(((int)shape.c.x + shape.x), (int)shape.c.y + shape.y, ((int)shape.d.x + shape.x), (int)shape.d.y + shape.y);[m
             drawLine(((int)shape.d.x + shape.x), (int)shape.d.y + shape.y, ((int)shape.a.x + shape.x), (int)shape.a.y + shape.y);[m
 [m
[32m+[m
         }[m
 [m
         static void drawLine(int x1, int y1, int x2, int y2)[m

[33mcommit ba1601dc3ca84bc707203c5743c8d9ca6b9b9e95[m
Author: Yharlm <lambrins22gmail.com>
Date:   Wed May 28 11:40:18 2025 +0300

    Spins

[1mdiff --git a/Rotating shape/Program.cs b/Rotating shape/Program.cs[m
[1mindex 0fde641..04c0d63 100644[m
[1m--- a/Rotating shape/Program.cs[m	
[1m+++ b/Rotating shape/Program.cs[m	
[36m@@ -1,4 +1,5 @@[m
[31m-ï»¿using System.Runtime.CompilerServices;[m
[32m+[m[32mï»¿using System.ComponentModel;[m
[32m+[m[32musing System.Runtime.CompilerServices;[m
 [m
 namespace Rotating_shape[m
 {[m
[36m@@ -27,6 +28,17 @@[m [mnamespace Rotating_shape[m
             public point a, b, c, d;[m
             public int x, y;[m
             public int length = 1;[m
[32m+[m
[32m+[m[32m            public shape(int size)[m
[32m+[m[32m            {[m
[32m+[m[41m                [m
[32m+[m[32m                int s = size;[m
[32m+[m[41m                [m
[32m+[m[32m                a = new point(-1, -1, s);[m
[32m+[m[32m                b = new point(1, -1, s);[m
[32m+[m[32m                c = new point(1, 1, s);[m
[32m+[m[32m                d = new point(-1, 1, s);[m
[32m+[m[32m            }[m
         }[m
 [m
         static void Rotate(float angle, shape shape)[m
[36m@@ -61,29 +73,55 @@[m [mnamespace Rotating_shape[m
         }[m
         static void Main(string[] args)[m
         {[m
[31m-            int a = 0;[m
[31m-            int s = 6;[m
[31m-            shape square = new shape();[m
[31m-            square.a = new point(-1,-1, s);[m
[31m-            square.b = new point(1, -1, s);[m
[31m-            square.c = new point(1, 1, s);[m
[31m-            square.d = new point(-1, 1, s);[m
[31m-            square.x = 10;[m
[31m-            square.y = 10;[m
[32m+[m[32m            float time = 0;[m
[32m+[m[32m            Thread deltatime = new Thread(() =>[m
[32m+[m[32m            {[m
[32m+[m[32m                while (true)[m
[32m+[m[32m                {[m
[32m+[m[32m                    Thread.Sleep(1);[m
[32m+[m[32m                    time += 0.001f; // Increment time by 1 millisecond[m
[32m+[m[32m                }[m
[32m+[m[32m            });[m
[32m+[m
[32m+[m
[32m+[m[32m            shape square = new shape(21);[m
[32m+[m[32m            shape square2 = new shape(17);[m
[32m+[m[32m            square.x = 70;[m
[32m+[m[32m            square.y = 60;[m
[32m+[m[32m            square2.x = 70;[m
[32m+[m[32m            square2.y = 60;[m
[32m+[m[32m            shape square3 = new shape(10);[m
[32m+[m[32m            shape square4 = new shape(13);[m
[32m+[m[32m            square3.x = 70;[m
[32m+[m[32m            square3.y = 60;[m
[32m+[m[32m            square4.x = 70;[m
[32m+[m[32m            square4.y = 60;[m
[32m+[m[32m            Console.ReadLine();[m
             while(true)[m
             {[m
[31m-                Rotate(a, square);[m
[31m-                WriteAt("#", square);[m
[31m-                Console.ReadLine();[m
[32m+[m
[32m+[m[41m                [m
[32m+[m[32m                Thread.Sleep(10);[m
                 Console.Clear();[m
[31m-                a += 1;[m
[32m+[m[32m                Rotate(5, square);[m
[32m+[m[32m                Rotate(-2, square2);[m
[32m+[m[32m                WriteAt("â–ˆâ–ˆ", square);[m
[32m+[m[32m                WriteAt("â–ˆâ–ˆ", square2);[m
[32m+[m[32m                Rotate(3, square3);[m
[32m+[m[32m                Rotate(1, square4);[m
[32m+[m[32m                WriteAt("â–ˆâ–ˆ", square3);[m
[32m+[m[32m                WriteAt("â–ˆâ–ˆ", square4);[m
[32m+[m
[32m+[m
[32m+[m
             }[m
[31m-           [m
[32m+[m
 [m
         }[m
 [m
         static void WriteAt(string text, int x, int y)[m
         {[m
[32m+[m
             Console.SetCursorPosition(x, y);[m
             Console.Write(text);[m
         }[m
[36m@@ -91,10 +129,35 @@[m [mnamespace Rotating_shape[m
         {[m
             int lenght = shape.length;[m
             WriteAt(text, 2*((int)shape.a.x + shape.x), (int)shape.a.y+shape.y);[m
[32m+[m
             WriteAt(text, 2*((int)shape.b.x + shape.x), (int)shape.b.y+shape.y);[m
             [m
             WriteAt(text, 2*((int)shape.c.x + shape.x), (int)shape.c.y+shape.y);[m
             WriteAt(text, 2*((int)shape.d.x + shape.x), (int)shape.d.y+shape.y);[m
[32m+[m[32m            drawLine(((int)shape.a.x + shape.x), (int)shape.a.y + shape.y,((int)shape.b.x + shape.x), (int)shape.b.y + shape.y);[m
[32m+[m[32m            drawLine(((int)shape.b.x + shape.x), (int)shape.b.y + shape.y, ((int)shape.c.x + shape.x), (int)shape.c.y + shape.y);[m
[32m+[m[32m            drawLine(((int)shape.c.x + shape.x), (int)shape.c.y + shape.y, ((int)shape.d.x + shape.x), (int)shape.d.y + shape.y);[m
[32m+[m[32m            drawLine(((int)shape.d.x + shape.x), (int)shape.d.y + shape.y, ((int)shape.a.x + shape.x), (int)shape.a.y + shape.y);[m
[32m+[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        static void drawLine(int x1, int y1, int x2, int y2)[m
[32m+[m[32m        {[m
[32m+[m[32m            int dx = x2 - x1;[m
[32m+[m[32m            int dy = y2 - y1;[m
[32m+[m[32m            int steps = Math.Max(Math.Abs(dx), Math.Abs(dy));[m
[32m+[m[32m            float xIncrement = (float)dx / steps;[m
[32m+[m[32m            float yIncrement = (float)dy / steps;[m
[32m+[m
[32m+[m[32m            float x = x1;[m
[32m+[m[32m            float y = y1;[m
[32m+[m
[32m+[m[32m            for (int i = 0; i <= steps; i++)[m
[32m+[m[32m            {[m
[32m+[m[32m                WriteAt("â–ˆâ–ˆ", (int)x*2, (int)y);[m
[32m+[m[32m                x += xIncrement;[m
[32m+[m[32m                y += yIncrement;[m
[32m+[m[32m            }[m
         }[m
     }[m
 }[m

[33mcommit 85cf42ac8a03d6cb492a9facbd4ffed9903a3f79[m
Author: Students <Students@DESKTOP-DAPA1OB>
Date:   Mon May 26 20:35:18 2025 -1100

    e

[1mdiff --git a/Rotating shape/Program.cs b/Rotating shape/Program.cs[m
[1mindex dedd337..0fde641 100644[m
[1m--- a/Rotating shape/Program.cs[m	
[1m+++ b/Rotating shape/Program.cs[m	
[36m@@ -36,7 +36,27 @@[m [mnamespace Rotating_shape[m
             float cos = (float)Math.Cos(radians);[m
             float sin = (float)Math.Sin(radians);[m
             // Rotate each point[m
[31m-            shape.a.x *= cos + sin;[m
[32m+[m[32m            point tempA = new point(shape.a.x, shape.a.y);[m
[32m+[m[32m            point tempB = new point(shape.b.x, shape.b.y);[m
[32m+[m[32m            point tempC = new point(shape.c.x, shape.c.y);[m
[32m+[m[32m            point tempD = new point(shape.d.x, shape.d.y);[m
[32m+[m
[32m+[m[32m            tempA.x = shape.a.x * cos - shape.a.y * sin;[m
[32m+[m[32m            tempA.y = shape.a.x * sin + shape.a.y * cos;[m
[32m+[m[32m            tempB.x = shape.b.x * cos - shape.b.y * sin;[m
[32m+[m[32m            tempB.y = shape.b.x * sin + shape.b.y * cos;[m
[32m+[m[32m            tempC.x = shape.c.x * cos - shape.c.y * sin;[m
[32m+[m[32m            tempC.y = shape.c.x * sin + shape.c.y * cos;[m
[32m+[m[32m            tempD.x = shape.d.x * cos - shape.d.y * sin;[m
[32m+[m[32m            tempD.y = shape.d.x * sin + shape.d.y * cos;[m
[32m+[m
[32m+[m[32m            // Update the shape points[m
[32m+[m[32m            shape.a = tempA;[m
[32m+[m[32m            shape.b = tempB;[m
[32m+[m[32m            shape.c = tempC;[m
[32m+[m[32m                shape.d = tempD;[m
[32m+[m
[32m+[m[41m            [m
 [m
         }[m
         static void Main(string[] args)[m
[36m@@ -55,7 +75,8 @@[m [mnamespace Rotating_shape[m
                 Rotate(a, square);[m
                 WriteAt("#", square);[m
                 Console.ReadLine();[m
[31m-                a += 10;[m
[32m+[m[32m                Console.Clear();[m
[32m+[m[32m                a += 1;[m
             }[m
            [m
 [m

[33mcommit 1160c04df22b7cf2bf5678ae5fd6c40def83e362[m
Author: Students <Students@DESKTOP-DAPA1OB>
Date:   Mon May 26 20:31:23 2025 -1100

    Add project files.

[1mdiff --git a/Rotating shape.sln b/Rotating shape.sln[m
[1mnew file mode 100644[m
[1mindex 0000000..4447355[m
[1m--- /dev/null[m
[1m+++ b/Rotating shape.sln[m	
[36m@@ -0,0 +1,25 @@[m
[32m+[m[32mï»¿[m
[32m+[m[32mMicrosoft Visual Studio Solution File, Format Version 12.00[m
[32m+[m[32m# Visual Studio Version 17[m
[32m+[m[32mVisualStudioVersion = 17.9.34622.214[m
[32m+[m[32mMinimumVisualStudioVersion = 10.0.40219.1[m
[32m+[m[32mProject("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Rotating shape", "Rotating shape\Rotating shape.csproj", "{F241E483-3E08-4E29-AC2A-A2581EDB8F2A}"[m
[32m+[m[32mEndProject[m
[32m+[m[32mGlobal[m
[32m+[m	[32mGlobalSection(SolutionConfigurationPlatforms) = preSolution[m
[32m+[m		[32mDebug|Any CPU = Debug|Any CPU[m
[32m+[m		[32mRelease|Any CPU = Release|Any CPU[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m	[32mGlobalSection(ProjectConfigurationPlatforms) = postSolution[m
[32m+[m		[32m{F241E483-3E08-4E29-AC2A-A2581EDB8F2A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU[m
[32m+[m		[32m{F241E483-3E08-4E29-AC2A-A2581EDB8F2A}.Debug|Any CPU.Build.0 = Debug|Any CPU[m
[32m+[m		[32m{F241E483-3E08-4E29-AC2A-A2581EDB8F2A}.Release|Any CPU.ActiveCfg = Release|Any CPU[m
[32m+[m		[32m{F241E483-3E08-4E29-AC2A-A2581EDB8F2A}.Release|Any CPU.Build.0 = Release|Any CPU[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m	[32mGlobalSection(SolutionProperties) = preSolution[m
[32m+[m		[32mHideSolutionNode = FALSE[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m	[32mGlobalSection(ExtensibilityGlobals) = postSolution[m
[32m+[m		[32mSolutionGuid = {8DE6D49A-A513-486B-B502-C13839C09B15}[m
[32m+[m	[32mEndGlobalSection[m
[32m+[m[32mEndGlobal[m
[1mdiff --git a/Rotating shape/Program.cs b/Rotating shape/Program.cs[m
[1mnew file mode 100644[m
[1mindex 0000000..dedd337[m
[1m--- /dev/null[m
[1m+++ b/Rotating shape/Program.cs[m	
[36m@@ -0,0 +1,79 @@[m
[32m+[m[32mï»¿using System.Runtime.CompilerServices;[m
[32m+[m
[32m+[m[32mnamespace Rotating_shape[m
[32m+[m[32m{[m
[32m+[m[32m    internal class Program[m
[32m+[m[32m    {[m
[32m+[m
[32m+[m[32m        class point[m
[32m+[m[32m        {[m
[32m+[m[32m            public double x = 0;[m
[32m+[m[32m            public double y = 0;[m
[32m+[m
[32m+[m[32m            public point(double x, double y)[m
[32m+[m[32m            {[m
[32m+[m[32m                this.x = x;[m
[32m+[m[32m                this.y = y;[m
[32m+[m[32m            }[m
[32m+[m[32m            public point(double x, double y,int size)[m
[32m+[m[32m            {[m
[32m+[m[32m                this.x = x*size;[m
[32m+[m[32m                this.y = y*size;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        class shape[m
[32m+[m[32m        {[m
[32m+[m[32m            public point a, b, c, d;[m
[32m+[m[32m            public int x, y;[m
[32m+[m[32m            public int length = 1;[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        static void Rotate(float angle, shape shape)[m
[32m+[m[32m        {[m
[32m+[m[32m            float radians = angle * (float)(Math.PI / 180.0);[m
[32m+[m[32m            //Matrix for rotation[m
[32m+[m[32m            float cos = (float)Math.Cos(radians);[m
[32m+[m[32m            float sin = (float)Math.Sin(radians);[m
[32m+[m[32m            // Rotate each point[m
[32m+[m[32m            shape.a.x *= cos + sin;[m
[32m+[m
[32m+[m[32m        }[m
[32m+[m[32m        static void Main(string[] args)[m
[32m+[m[32m        {[m
[32m+[m[32m            int a = 0;[m
[32m+[m[32m            int s = 6;[m
[32m+[m[32m            shape square = new shape();[m
[32m+[m[32m            square.a = new point(-1,-1, s);[m
[32m+[m[32m            square.b = new point(1, -1, s);[m
[32m+[m[32m            square.c = new point(1, 1, s);[m
[32m+[m[32m            square.d = new point(-1, 1, s);[m
[32m+[m[32m            square.x = 10;[m
[32m+[m[32m            square.y = 10;[m
[32m+[m[32m            while(true)[m
[32m+[m[32m            {[m
[32m+[m[32m                Rotate(a, square);[m
[32m+[m[32m                WriteAt("#", square);[m
[32m+[m[32m                Console.ReadLine();[m
[32m+[m[32m                a += 10;[m
[32m+[m[32m            }[m
[32m+[m[41m           [m
[32m+[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        static void WriteAt(string text, int x, int y)[m
[32m+[m[32m        {[m
[32m+[m[32m            Console.SetCursorPosition(x, y);[m
[32m+[m[32m            Console.Write(text);[m
[32m+[m[32m        }[m
[32m+[m[32m        static void WriteAt(string text, shape shape)[m
[32m+[m[32m        {[m
[32m+[m[32m            int lenght = shape.length;[m
[32m+[m[32m            WriteAt(text, 2*((int)shape.a.x + shape.x), (int)shape.a.y+shape.y);[m
[32m+[m[32m            WriteAt(text, 2*((int)shape.b.x + shape.x), (int)shape.b.y+shape.y);[m
[32m+[m[41m            [m
[32m+[m[32m            WriteAt(text, 2*((int)shape.c.x + shape.x), (int)shape.c.y+shape.y);[m
[32m+[m[32m            WriteAt(text, 2*((int)shape.d.x + shape.x), (int)shape.d.y+shape.y);[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[1mdiff --git a/Rotating shape/Rotating shape.csproj b/Rotating shape/Rotating shape.csproj[m
[1mnew file mode 100644[m
[1mindex 0000000..cd0029e[m
[1m--- /dev/null[m
[1m+++ b/Rotating shape/Rotating shape.csproj[m	
[36m@@ -0,0 +1,11 @@[m
[32m+[m[32mï»¿<Project Sdk="Microsoft.NET.Sdk">[m
[32m+[m
[32m+[m[32m  <PropertyGroup>[m
[32m+[m[32m    <OutputType>Exe</OutputType>[m
[32m+[m[32m    <TargetFramework>net8.0</TargetFramework>[m
[32m+[m[32m    <RootNamespace>Rotating_shape</RootNamespace>[m
[32m+[m[32m    <ImplicitUsings>enable</ImplicitUsings>[m
[32m+[m[32m    <Nullable>enable</Nullable>[m
[32m+[m[32m  </PropertyGroup>[m
[32m+[m
[32m+[m[32m</Project>[m

[33mcommit 8ac923641a8ef832376310890179f64cfc0bedba[m
Author: Students <Students@DESKTOP-DAPA1OB>
Date:   Mon May 26 20:31:21 2025 -1100

    Add .gitattributes and .gitignore.

[1mdiff --git a/.gitattributes b/.gitattributes[m
[1mnew file mode 100644[m
[1mindex 0000000..1ff0c42[m
[1m--- /dev/null[m
[1m+++ b/.gitattributes[m
[36m@@ -0,0 +1,63 @@[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m# Set default behavior to automatically normalize line endings.[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m* text=auto[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m# Set default behavior for command prompt diff.[m
[32m+[m[32m#[m
[32m+[m[32m# This is need for earlier builds of msysgit that does not have it on by[m
[32m+[m[32m# default for csharp files.[m
[32m+[m[32m# Note: This is only used by command line[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m#*.cs     diff=csharp[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m# Set the merge driver for project and solution files[m
[32m+[m[32m#[m
[32m+[m[32m# Merging from the command prompt will add diff markers to the files if there[m
[32m+[m[32m# are conflicts (Merging from VS is not affected by the settings below, in VS[m
[32m+[m[32m# the diff markers are never inserted). Diff markers may cause the following[m[41m [m
[32m+[m[32m# file extensions to fail to load in VS. An alternative would be to treat[m
[32m+[m[32m# these files as binary and thus will always conflict and require user[m
[32m+[m[32m# intervention with every merge. To do so, just uncomment the entries below[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m#*.sln       merge=binary[m
[32m+[m[32m#*.csproj    merge=binary[m
[32m+[m[32m#*.vbproj    merge=binary[m
[32m+[m[32m#*.vcxproj   merge=binary[m
[32m+[m[32m#*.vcproj    merge=binary[m
[32m+[m[32m#*.dbproj    merge=binary[m
[32m+[m[32m#*.fsproj    merge=binary[m
[32m+[m[32m#*.lsproj    merge=binary[m
[32m+[m[32m#*.wixproj   merge=binary[m
[32m+[m[32m#*.modelproj merge=binary[m
[32m+[m[32m#*.sqlproj   merge=binary[m
[32m+[m[32m#*.wwaproj   merge=binary[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m# behavior for image files[m
[32m+[m[32m#[m
[32m+[m[32m# image files are treated as binary by default.[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m#*.jpg   binary[m
[32m+[m[32m#*.png   binary[m
[32m+[m[32m#*.gif   binary[m
[32m+[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m# diff behavior for common document formats[m
[32m+[m[32m#[m[41m [m
[32m+[m[32m# Convert binary document formats to text before diffing them. This feature[m
[32m+[m[32m# is only available from the command line. Turn it on by uncommenting the[m[41m [m
[32m+[m[32m# entries below.[m
[32m+[m[32m###############################################################################[m
[32m+[m[32m#*.doc   diff=astextplain[m
[32m+[m[32m#*.DOC   diff=astextplain[m
[32m+[m[32m#*.docx  diff=astextplain[m
[32m+[m[32m#*.DOCX  diff=astextplain[m
[32m+[m[32m#*.dot   diff=astextplain[m
[32m+[m[32m#*.DOT   diff=astextplain[m
[32m+[m[32m#*.pdf   diff=astextplain[m
[32m+[m[32m#*.PDF   diff=astextplain[m
[32m+[m[32m#*.rtf   diff=astextplain[m
[32m+[m[32m#*.RTF   diff=astextplain[m
[1mdiff --git a/.gitignore b/.gitignore[m
[1mnew file mode 100644[m
[1mindex 0000000..9491a2f[m
[1m--- /dev/null[m
[1m+++ b/.gitignore[m
[36m@@ -0,0 +1,363 @@[m
[32m+[m[32m## Ignore Visual Studio temporary files, build results, and[m
[32m+[m[32m## files generated by popular Visual Studio add-ons.[m
[32m+[m[32m##[m
[32m+[m[32m## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore[m
[32m+[m
[32m+[m[32m# User-specific files[m
[32m+[m[32m*.rsuser[m
[32m+[m[32m*.suo[m
[32m+[m[32m*.user[m
[32m+[m[32m*.userosscache[m
[32m+[m[32m*.sln.docstates[m
[32m+[m
[32m+[m[32m# User-specific files (MonoDevelop/Xamarin Studio)[m
[32m+[m[32m*.userprefs[m
[32m+[m
[32m+[m[32m# Mono auto generated files[m
[32m+[m[32mmono_crash.*[m
[32m+[m
[32m+[m[32m# Build results[m
[32m+[m[32m[Dd]ebug/[m
[32m+[m[32m[Dd]ebugPublic/[m
[32m+[m[32m[Rr]elease/[m
[32m+[m[32m[Rr]eleases/[m
[32m+[m[32mx64/[m
[32m+[m[32mx86/[m
[32m+[m[32m[Ww][Ii][Nn]32/[m
[32m+[m[32m[Aa][Rr][Mm]/[m
[32m+[m[32m[Aa][Rr][Mm]64/[m
[32m+[m[32mbld/[m
[32m+[m[32m[Bb]in/[m
[32m+[m[32m[Oo]bj/[m
[32m+[m[32m[Oo]ut/[m
[32m+[m[32m[Ll]og/[m
[32m+[m[32m[Ll]ogs/[m
[32m+[m
[32m+[m[32m# Visual Studio 2015/2017 cache/options directory[m
[32m+[m[32m.vs/[m
[32m+[m[32m# Uncomment if you have tasks that create the project's static files in wwwroot[m
[32m+[m[32m#wwwroot/[m
[32m+[m
[32m+[m[32m# Visual Studio 2017 auto generated files[m
[32m+[m[32mGenerated\ Files/[m
[32m+[m
[32m+[m[32m# MSTest test Results[m
[32m+[m[32m[Tt]est[Rr]esult*/[m
[32m+[m[32m[Bb]uild[Ll]og.*[m
[32m+[m
[32m+[m[32m# NUnit[m
[32m+[m[32m*.VisualState.xml[m
[32m+[m[32mTestResult.xml[m
[32m+[m[32mnunit-*.xml[m
[32m+[m
[32m+[m[32m# Build Results of an ATL Project[m
[32m+[m[32m[Dd]ebugPS/[m
[32m+[m[32m[Rr]eleasePS/[m
[32m+[m[32mdlldata.c[m
[32m+[m
[32m+[m[32m# Benchmark Results[m
[32m+[m[32mBenchmarkDotNet.Artifacts/[m
[32m+[m
[32m+[m[32m# .NET Core[m
[32m+[m[32mproject.lock.json[m
[32m+[m[32mproject.fragment.lock.json[m
[32m+[m[32martifacts/[m
[32m+[m
[32m+[m[32m# ASP.NET Scaffolding[m
[32m+[m[32mScaffoldingReadMe.txt[m
[32m+[m
[32m+[m[32m# StyleCop[m
[32m+[m[32mStyleCopReport.xml[m
[32m+[m
[32m+[m[32m# Files built by Visual Studio[m
[32m+[m[32m*_i.c[m
[32m+[m[32m*_p.c[m
[32m+[m[32m*_h.h[m
[32m+[m[32m*.ilk[m
[32m+[m[32m*.meta[m
[32m+[m[32m*.obj[m
[32m+[m[32m*.iobj[m
[32m+[m[32m*.pch[m
[32m+[m[32m*.pdb[m
[32m+[m[32m*.ipdb[m
[32m+[m[32m*.pgc[m
[32m+[m[32m*.pgd[m
[32m+[m[32m*.rsp[m
[32m+[m[32m*.sbr[m
[32m+[m[32m*.tlb[m
[32m+[m[32m*.tli[m
[32m+[m[32m*.tlh[m
[32m+[m[32m*.tmp[m
[32m+[m[32m*.tmp_proj[m
[32m+[m[32m*_wpftmp.csproj[m
[32m+[m[32m*.log[m
[32m+[m[32m*.vspscc[m
[32m+[m[32m*.vssscc[m
[32m+[m[32m.builds[m
[32m+[m[32m*.pidb[m
[32m+[m[32m*.svclog[m
[32m+[m[32m*.scc[m
[32m+[m
[32m+[m[32m# Chutzpah Test files[m
[32m+[m[32m_Chutzpah*[m
[32m+[m
[32m+[m[32m# Visual C++ cache files[m
[32m+[m[32mipch/[m
[32m+[m[32m*.aps[m
[32m+[m[32m*.ncb[m
[32m+[m[32m*.opendb[m
[32m+[m[32m*.opensdf[m
[32m+[m[32m*.sdf[m
[32m+[m[32m*.cachefile[m
[32m+[m[32m*.VC.db[m
[32m+[m[32m*.VC.VC.opendb[m
[32m+[m
[32m+[m[32m# Visual Studio profiler[m
[32m+[m[32m*.psess[m
[32m+[m[32m*.vsp[m
[32m+[m[32m*.vspx[m
[32m+[m[32m*.sap[m
[32m+[m
[32m+[m[32m# Visual Studio Trace Files[m
[32m+[m[32m*.e2e[m
[32m+[m
[32m+[m[32m# TFS 2012 Local Workspace[m
[32m+[m[32m$tf/[m
[32m+[m
[32m+[m[32m# Guidance Automation Toolkit[m
[32m+[m[32m*.gpState[m
[32m+[m
[32m+[m[32m# ReSharper is a .NET coding add-in[m
[32m+[m[32m_ReSharper*/[m
[32m+[m[32m*.[Rr]e[Ss]harper[m
[32m+[m[32m*.DotSettings.user[m
[32m+[m
[32m+[m[32m# TeamCity is a build add-in[m
[32m+[m[32m_TeamCity*[m
[32m+[m
[32m+[m[32m# DotCover is a Code Coverage Tool[m
[32m+[m[32m*.dotCover[m
[32m+[m
[32m+[m[32m# AxoCover is a Code Coverage Tool[m
[32m+[m[32m.axoCover/*[m
[32m+[m[32m!.axoCover/settings.json[m
[32m+[m
[32m+[m[32m# Coverlet is a free, cross platform Code Coverage Tool[m
[32m+[m[32mcoverage*.json[m
[32m+[m[32mcoverage*.xml[m
[32m+[m[32mcoverage*.info[m
[32m+[m
[32m+[m[32m# Visual Studio code coverage results[m
[32m+[m[32m*.coverage[m
[32m+[m[32m*.coveragexml[m
[32m+[m
[32m+[m[32m# NCrunch[m
[32m+[m[32m_NCrunch_*[m
[32m+[m[32m.*crunch*.local.xml[m
[32m+[m[32mnCrunchTemp_*[m
[32m+[m
[32m+[m[32m# MightyMoose[m
[32m+[m[32m*.mm.*[m
[32m+[m[32mAutoTest.Net/[m
[32m+[m
[32m+[m[32m# Web workbench (sass)[m
[32m+[m[32m.sass-cache/[m
[32m+[m
[32m+[m[32m# Installshield output folder[m
[32m+[m[32m[Ee]xpress/[m
[32m+[m
[32m+[m[32m# DocProject is a documentation generator add-in[m
[32m+[m[32mDocProject/buildhelp/[m
[32m+[m[32mDocProject/Help/*.HxT[m
[32m+[m[32mDocProject/Help/*.HxC[m
[32m+[m[32mDocProject/Help/*.hhc[m
[32m+[m[32mDocProject/Help/*.hhk[m
[32m+[m[32mDocProject/Help/*.hhp[m
[32m+[m[32mDocProject/Help/Html2[m
[32m+[m[32mDocProject/Help/html[m
[32m+[m
[32m+[m[32m# Click-Once directory[m
[32m+[m[32mpublish/[m
[32m+[m
[32m+[m[32m# Publish Web Output[m
[32m+[m[32m*.[Pp]ublish.xml[m
[32m+[m[32m*.azurePubxml[m
[32m+[m[32m# Note: Comment the next line if you want to checkin your web deploy settings,[m
[32m+[m[32m# but database connection strings (with potential passwords) will be unencrypted[m
[32m+[m[32m*.pubxml[m
[32m+[m[32m*.publishproj[m
[32m+[m
[32m+[m[32m# Microsoft Azure Web App publish settings. Comment the next line if you want to[m
[32m+[m[32m# checkin your Azure Web App publish settings, but sensitive information contained[m
[32m+[m[32m# in these scripts will be unencrypted[m
[32m+[m[32mPublishScripts/[m
[32m+[m
[32m+[m[32m# NuGet Packages[m
[32m+[m[32m*.nupkg[m
[32m+[m[32m# NuGet Symbol Packages[m
[32m+[m[32m*.snupkg[m
[32m+[m[32m# The packages folder can be ignored because of Package Restore[m
[32m+[m[32m**/[Pp]ackages/*[m
[32m+[m[32m# except build/, which is used as an MSBuild target.[m
[32m+[m[32m!**/[Pp]ackages/build/[m
[32m+[m[32m# Uncomment if necessary however generally it will be regenerated when needed[m
[32m+[m[32m#!**/[Pp]ackages/repositories.config[m
[32m+[m[32m# NuGet v3's project.json files produces more ignorable files[m
[32m+[m[32m*.nuget.props[m
[32m+[m[32m*.nuget.targets[m
[32m+[m
[32m+[m[32m# Microsoft Azure Build Output[m
[32m+[m[32mcsx/[m
[32m+[m[32m*.build.csdef[m
[32m+[m
[32m+[m[32m# Microsoft Azure Emulator[m
[32m+[m[32mecf/[m
[32m+[m[32mrcf/[m
[32m+[m
[32m+[m[32m# Windows Store app package directories and files[m
[32m+[m[32mAppPackages/[m
[32m+[m[32mBundleArtifacts/[m
[32m+[m[32mPackage.StoreAssociation.xml[m
[32m+[m[32m_pkginfo.txt[m
[32m+[m[32m*.appx[m
[32m+[m[32m*.appxbundle[m
[32m+[m[32m*.appxupload[m
[32m+[m
[32m+[m[32m# Visual Studio cache files[m
[32m+[m[32m# files ending in .cache can be ignored[m
[32m+[m[32m*.[Cc]ache[m
[32m+[m[32m# but keep track of directories ending in .cache[m
[32m+[m[32m!?*.[Cc]ache/[m
[32m+[m
[32m+[m[32m# Others[m
[32m+[m[32mClientBin/[m
[32m+[m[32m~$*[m
[32m+[m[32m*~[m
[32m+[m[32m*.dbmdl[m
[32m+[m[32m*.dbproj.schemaview[m
[32m+[m[32m*.jfm[m
[32m+[m[32m*.pfx[m
[32m+[m[32m*.publishsettings[m
[32m+[m[32morleans.codegen.cs[m
[32m+[m
[32m+[m[32m# Including strong name files can present a security risk[m
[32m+[m[32m# (https://github.com/github/gitignore/pull/2483#issue-259490424)[m
[32m+[m[32m#*.snk[m
[32m+[m
[32m+[m[32m# Since there are multiple workflows, uncomment next line to ignore bower_components[m
[32m+[m[32m# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)[m
[32m+[m[32m#bower_components/[m
[32m+[m
[32m+[m[32m# RIA/Silverlight projects[m
[32m+[m[32mGenerated_Code/[m
[32m+[m
[32m+[m[32m# Backup & report files from converting an old project file[m
[32m+[m[32m# to a newer Visual Studio version. Backup files are not needed,[m
[32m+[m[32m# because we have git ;-)[m
[32m+[m[32m_UpgradeReport_Files/[m
[32m+[m[32mBackup*/[m
[32m+[m[32mUpgradeLog*.XML[m
[32m+[m[32mUpgradeLog*.htm[m
[32m+[m[32mServiceFabricBackup/[m
[32m+[m[32m*.rptproj.bak[m
[32m+[m
[32m+[m[32m# SQL Server files[m
[32m+[m[32m*.mdf[m
[32m+[m[32m*.ldf[m
[32m+[m[32m*.ndf[m
[32m+[m
[32m+[m[32m# Business Intelligence projects[m
[32m+[m[32m*.rdl.data[m
[32m+[m[32m*.bim.layout[m
[32m+[m[32m*.bim_*.settings[m
[32m+[m[32m*.rptproj.rsuser[m
[32m+[m[32m*- [Bb]ackup.rdl[m
[32m+[m[32m*- [Bb]ackup ([0-9]).rdl[m
[32m+[m[32m*- [Bb]ackup ([0-9][0-9]).rdl[m
[32m+[m
[32m+[m[32m# Microsoft Fakes[m
[32m+[m[32mFakesAssemblies/[m
[32m+[m
[32m+[m[32m# GhostDoc plugin setting file[m
[32m+[m[32m*.GhostDoc.xml[m
[32m+[m
[32m+[m[32m# Node.js Tools for Visual Studio[m
[32m+[m[32m.ntvs_analysis.dat[m
[32m+[m[32mnode_modules/[m
[32m+[m
[32m+[m[32m# Visual Studio 6 build log[m
[32m+[m[32m*.plg[m
[32m+[m
[32m+[m[32m# Visual Studio 6 workspace options file[m
[32m+[m[32m*.opt[m
[32m+[m
[32m+[m[32m# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)[m
[32m+[m[32m*.vbw[m
[32m+[m
[32m+[m[32m# Visual Studio LightSwitch build output[m
[32m+[m[32m**/*.HTMLClient/GeneratedArtifacts[m
[32m+[m[32m**/*.DesktopClient/GeneratedArtifacts[m
[32m+[m[32m**/*.DesktopClient/ModelManifest.xml[m
[32m+[m[32m**/*.Server/GeneratedArtifacts[m
[32m+[m[32m**/*.Server/ModelManifest.xml[m
[32m+[m[32m_Pvt_Extensions[m
[32m+[m
[32m+[m[32m# Paket dependency manager[m
[32m+[m[32m.paket/paket.exe[m
[32m+[m[32mpaket-files/[m
[32m+[m
[32m+[m[32m# FAKE - F# Make[m
[32m+[m[32m.fake/[m
[32m+[m
[32m+[m[32m# CodeRush personal settings[m
[32m+[m[32m.cr/personal[m
[32m+[m
[32m+[m[32m# Python Tools for Visual Studio (PTVS)[m
[32m+[m[32m__pycache__/[m
[32m+[m[32m*.pyc[m
[32m+[m
[32m+[m[32m# Cake - Uncomment if you are using it[m
[32m+[m[32m# tools/**[m
[32m+[m[32m# !tools/packages.config[m
[32m+[m
[32m+[m[32m# Tabs Studio[m
[32m+[m[32m*.tss[m
[32m+[m
[32m+[m[32m# Telerik's JustMock configuration file[m
[32m+[m[32m*.jmconfig[m
[32m+[m
[32m+[m[32m# BizTalk build output[m
[32m+[m[32m*.btp.cs[m
[32m+[m[32m*.btm.cs[m
[32m+[m[32m*.odx.cs[m
[32m+[m[32m*.xsd.cs[m
[32m+[m
[32m+[m[32m# OpenCover UI analysis results[m
[32m+[m[32mOpenCover/[m
[32m+[m
[32m+[m[32m# Azure Stream Analytics local run output[m
[32m+[m[32mASALocalRun/[m
[32m+[m
[32m+[m[32m# MSBuild Binary and Structured Log[m
[32m+[m[32m*.binlog[m
[32m+[m
[32m+[m[32m# NVidia Nsight GPU debugger configuration file[m
[32m+[m[32m*.nvuser[m
[32m+[m
[32m+[m[32m# MFractors (Xamarin productivity tool) working folder[m
[32m+[m[32m.mfractor/[m
[32m+[m
[32m+[m[32m# Local History for Visual Studio[m
[32m+[m[32m.localhistory/[m
[32m+[m
[32m+[m[32m# BeatPulse healthcheck temp database[m
[32m+[m[32mhealthchecksdb[m
[32m+[m
[32m+[m[32m# Backup folder for Package Reference Convert tool in Visual Studio 2017[m
[32m+[m[32mMigrationBackup/[m
[32m+[m
[32m+[m[32m# Ionide (cross platform F# VS Code tools) working folder[m
[32m+[m[32m.ionide/[m
[32m+[m
[32m+[m[32m# Fody - auto-generated XML schema[m
[32m+[m[32mFodyWeavers.xsd[m
\ No newline at end of file[m
